from __future__ import print_function
from usbrply import printer
from usbrply import parsers
from .printer import Printer, indented, indent_inc, indent_dec, get_indent
import sys
import binascii
from . import usb
from .util import myord


def comment(s):
    indented('//%s' % (s, ))


def bytes2AnonArray(buf):
    # Sample
    # (char[]){0x05, 0x40, 0x07, 0x3A}

    ret = "(char[]){"

    for start in range(0, len(buf), 16):
        # Break up long line
        if start:
            ret += "\n" + get_indent()
        nums = ["0x%02X" % x for x in buf[start:start + 16]]
        ret += ", ".join(nums)
    return ret + "}"


# Fall back to t_urb for original pcap format on Linux?
def gett(d):
    if "t" in d["submit"]:
        return d["submit"]["t"]
    elif "t_urb" in d["submit"]:
        return d["submit"]["t"]
    else:
        raise Exception(
            "Requested sleep but couldn't establish time reference")


class LibusbCPrinter(Printer):
    def __init__(self, argsj, verbose=None):
        Printer.__init__(self, argsj)
        self.prevd = None
        self.wrapper = argsj.get("wrapper", False)
        self.sleep = argsj.get("sleep", False)
        self.packet_numbers = argsj.get("packet_numbers", True)
        # FIXME
        self.vid = None
        self.pid = None
        if verbose is None:
            verbose = argsj.get("verbose", False)
        self.verbose = verbose
        self.argsj = argsj

    def print_imports(self):
        assert 0, "FIXME"
        print('''\
#include <stdio.h>
#include <string.h>
#include "libusb.h"
''',
              file=printer.print_file)

    def print_wrapper_header(self):
        print('''\
int validate_read(const uint8_t *expected, const uint8_t *actual, const char *msg):
    if expected != actual:
        printf("Failed %s\n" % msg)
        printf("  Expected; %s\n" % hexlify(expected,))
        printf("  Actual:   %s\n" % hexlify(actual,))

''',
              file=printer.print_file)
        print('int replay(libusb_device *dev) {', file=printer.print_file)
        indent_inc()
        print('''\
    int n_rw = 0;
    uint8_t buff[4096];
    (void)buff;
    int timeout = 0;
''',
              file=printer.print_file)

    def header(self):
        comment("Generated by usbrply")
        comment("cmd: %s" % (' '.join(sys.argv), ))
        indented("")

        if self.wrapper:
            assert 0, "FIXME"
            self.print_imports()
            print("", file=printer.print_file)
            self.print_wrapper_header()

    def footer(self):
        assert 0, "FIXME"
        if not self.wrapper:
            return
        print('''
int open_dev(void *usbcontext):
    if usbcontext is None:
        usbcontext = usb1.USBContext()

    struct libusb_device **list;
    ssize_t count = libusb_get_device_list(usb_ctx, &list);
    if (count < 0) {
        msg_perr("Getting the USB device list failed (%s)!\n", libusb_error_name(count));
        return NULL;
    }

    
    print('Scanning for devices...')
    for udev in usbcontext.getDeviceList(skip_on_error=True):
        vid = udev.getVendorID()
        pid = udev.getProductID()
        if (vid, pid) == (''' + "0x%04X, 0x%04X" % (self.vid, self.pid) + '''):
            print("")
            print("")
            print('Found device')
            print('Bus %03i Device %03i: ID %04x:%04x' % (
                udev.getBusNumber(),
                udev.getDeviceAddress(),
                vid,
                pid))
            return udev.open()
    raise Exception("Failed to find a device")

if __name__ == "__main__":
    import argparse 
    
    parser = argparse.ArgumentParser(description='Replay captured USB packets')
    args = parser.parse_args()

    usbcontext = usb1.USBContext()
    dev = open_dev(usbcontext)
    dev.claimInterface(0)
    dev.resetDevice()
    replay(dev)

''',
              file=printer.print_file)

    def packet_number_str(self, d):
        if self.packet_numbers:
            return "packet %s/%s" % (d["submit"]["packn"],
                                     d["complete"]["packn"])
        else:
            # TODO: consider counting instead of by captured index
            return "packet"

    def parse_data(self, d):
        if self.sleep and self.prevd and d["type"] != "comment":
            try:
                dt = gett(d) - gett(self.prevd)
            except KeyError:
                raise ValueError("Input JSON does not support timestamps")
            if dt >= 0.001:
                indented('time.sleep(%.3f)' % (dt, ))

        if d["type"] == "comment":
            comment(d["v"])
            return

        packet_numbering = self.packet_number_str(d)

        if "comments" in d:
            for c in d["comments"]:
                comment(c)

        if d["type"] == "controlRead":
            """
            int LIBUSB_CALL libusb_control_transfer(libusb_device_handle *dev_handle,
                uint8_t request_type, uint8_t bRequest, uint16_t wValue, uint16_t wIndex,
                unsigned char *data, uint16_t wLength, unsigned int timeout);
            """

            if d["wLength"]:
                data = "buff"
            else:
                data = "NULL"

            indented(
                "n_rw = libusb_control_transfer(dev, 0x%02X, 0x%02X, 0x%04X, 0x%04X, %s, 0x%04X, timeout)"
                % (d["bRequestType"], d["bRequest"], d["wValue"], d["wIndex"],
                   data, d["wLength"]))
            # validate_read((char[]){0x05, 0x40, 0x07, 0x3A}, 4, buff, n_rw, "packet 1/2");
            indented(
                "if (n_rw < 0 || validate_read(%s, buff, \"%s\")) { return n_rw; }"
                % (
                    bytes2AnonArray(binascii.unhexlify(d["data"])),
                    packet_numbering,
                ))
        elif d["type"] == "controlWrite":
            data = bytes2AnonArray(binascii.unhexlify(
                d["data"])) if d["data"] else "NULL"
            indented(
                "n_rw = libusb_control_transfer(dev, 0x%02X, 0x%02X, 0x%04X, 0x%04X, %s, 0x%04X, timeout)"
                % (d["bRequestType"], d["bRequest"], d["wValue"], d["wIndex"],
                   data, len(d["data"])))
            indented("if (n_rw < 0) { return n_rw; }")

        elif d["type"] == "bulkRead":
            assert 0, "fixme"
            data_str = "\"\""
            indented("buff = bulkRead(0x%02X, 0x%04X)" % (d["endp"], d["len"]))
            indented("validate_read(%s, buff, \"%s\")" % (bytes2AnonArray(
                binascii.unhexlify(d["data"])), packet_numbering))
        elif d["type"] == "bulkWrite":
            assert 0, "fixme"
            # Note that its the submit from earlier, not the ack that we care about
            data_str = bytes2AnonArray(binascii.unhexlify(d["data"]))
            # def bulkWrite(self, endpoint, data, timeout=0):
            indented("bulkWrite(0x%02X, %s)" % (d["endp"], data_str))

        elif d["type"] == "interruptIn":
            assert 0, "fixme"
            data_str = "\"\""
            indented("buff = interruptRead(0x%02X, 0x%04X)" %
                     (d["endp"], d["len"]))
            indented("validate_read(%s, buff, \"%s\")" % (bytes2AnonArray(
                binascii.unhexlify(d["data"])), packet_numbering))

        elif d["type"] == "interruptOut":
            assert 0, "fixme"
            data_str = bytes2AnonArray(binascii.unhexlify(d["data"]))
            indented("interruptWrite(0x%02X, %s)" % (d["endp"], data_str))
        elif d["type"] == "irpInfo":
            comment("IRP_INFO(): func %s" %
                    (d["submit"]["urb"]["usb_func_str"], ))
        elif d["type"] == "abortPipe":
            comment("ABORT_PIPE()")
        else:
            if self.verbose:
                print("LibusbPyPrinter WARNING: dropping %s" % (d["type"], ))

        # these aren't event added to JSON right now
        # print('%s# WARNING: omitting interrupt' % (indent,))

        if d["type"] != "comment":
            self.prevd = d

    def run(self, jgen):
        self.header()

        # Last wire command (ie non-comment)
        # Used to optionally generate timing
        self.prevd = None

        # Convert generator into static JSON
        # caches vid/pid among other things
        j = parsers.jgen2j(jgen)

        for d in j["data"]:
            self.parse_data(d)

        if self.wrapper and (self.vid is None or self.pid is None):
            if len(j["device2vidpid"]) != 1:
                raise Exception(
                    "Failed to guess vid/pid: found %u device entries" %
                    len(j["device2vidpid"]))
            for (vid, pid) in j["device2vidpid"].values():
                self.vid = vid
                self.pid = pid
        if self.wrapper:
            self.footer()
