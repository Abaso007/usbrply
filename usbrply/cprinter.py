from __future__ import print_function
from usbrply import printer
from usbrply import parsers
from .printer import Printer, indented, indent_inc, indent_dec, get_indent, indent_reset
import sys
import binascii
from . import usb
from .util import myord


def comment(s):
    indented('//%s' % (s, ))


def bytes2AnonArray(buf):
    # Sample
    # (char[]){0x05, 0x40, 0x07, 0x3A}

    ret = "(char[]){"

    chunk_size = 16
    for start in range(0, len(buf), chunk_size):
        # Break up long line
        if len(buf) > chunk_size:
            if start:
                ret += ","
            ret += "\n        " + get_indent()
        nums = ["0x%02X" % x for x in buf[start:start + 16]]
        ret += ", ".join(nums)
    return ret + "}"


# Fall back to t_urb for original pcap format on Linux?
def gett(d):
    if "t" in d["submit"]:
        return d["submit"]["t"]
    elif "t_urb" in d["submit"]:
        return d["submit"]["t"]
    else:
        raise Exception(
            "Requested sleep but couldn't establish time reference")


class LibusbCPrinter(Printer):
    def __init__(self, argsj, verbose=None):
        Printer.__init__(self, argsj)
        self.prevd = None
        self.wrapper = argsj.get("wrapper", False)
        self.sleep = argsj.get("sleep", False)
        self.packet_numbers = argsj.get("packet_numbers", True)
        # FIXME
        self.vid = None
        self.pid = None
        if verbose is None:
            verbose = argsj.get("verbose", False)
        self.verbose = verbose
        self.argsj = argsj

    def print_imports(self):
        print('''\
/*
Ubuntu quick start:
sudo apt-get install -y libusb-1.0-0-dev
usbrply -l --wrapper my.pcapng ->main.c
gcc -I/usr/include/libusb-1.0 main.c -lusb-1.0
./main
*/
#include <stdio.h>
#include <string.h>
#include <libusb.h>
''',
              file=printer.print_file)

    def print_macros(self):
        print('''\
//Automatically calculate expected buffer size
#define VALIDATE_READ(expected, actual, actual_size, msg) \
        validate_read(expected, sizeof(expected), actual, actual_size, msg)
#define RET_ON_ERR(_x) do { usbret = _x; if (usbret < 0) { return usbret; } } while(0)
#define RET_ON_XFER_ERR(_x, _nexpect) do { \
        usbret = _x; \
        if (usbret < 0) { \
            return usbret; \
        } \
        if (bytes_transferred != (_nexpect)) { \
            return -1; \
        } \
    } while(0)
''',
              file=printer.print_file)

    def print_wrapper_header(self):
        print('''\
const char *hexlify(const void *buf, size_t size) {
    //FIXME
    return NULL;
}

int validate_read(const uint8_t *expected, size_t expected_size, const uint8_t *actual, size_t actual_size, const char *msg) {
    if (expected_size != actual_size || memcmp(expected, actual, expected_size)) {
        printf("Failed %s\\n", msg);
        //printf("  Expected; %s\\n", hexlify(expected, expected_size));
        //printf("  Actual:   %s\\n", hexlify(actual, actual_size));
        return -1;
    }
    return 0;
}

''',
              file=printer.print_file)
        print('int replay(libusb_device_handle *devh) {',
              file=printer.print_file)
        indent_inc()
        print('''\
    //Error and/or size
    int usbret = 0;
    //XXX: size this automatically / better? Just be big for now
    uint8_t buff[16384];
    (void)buff;
    int timeout = 0;
    unsigned bytes_transferred = 0;
''',
              file=printer.print_file)

    def header(self):
        comment("Generated by usbrply")
        comment("***WARNING: libusb-c is alpha level quality***")
        comment("cmd: %s" % (' '.join(sys.argv), ))
        indented("")

        if self.wrapper:
            self.print_imports()
            print("", file=printer.print_file)
            self.print_macros()
            print("", file=printer.print_file)
            self.print_wrapper_header()
        else:
            self.print_macros()
        print("", file=printer.print_file)

    def footer(self):
        if not self.wrapper:
            return
        print('''
}

static struct libusb_device_handle *get_device(struct libusb_context *usb_ctx, uint16_t vid, uint16_t pid) {
    struct libusb_device **devices = NULL;
    ssize_t count = 0;

    count = libusb_get_device_list(usb_ctx, &devices);
    if (count < 0) {
        printf("Error getting device list: %ld (%s)\\n", count, libusb_error_name(count));
        return NULL;
    }

    printf("Scanning for devices...\\n");
    for (int devi = 0; devi < count; ++devi) {
        struct libusb_device *dev = devices[devi];
        struct libusb_device_descriptor desc;
        struct libusb_device_handle *devh = NULL;
        int usbret;

        usbret = libusb_get_device_descriptor(dev, &desc);
        if (usbret != 0) {
            printf("Error reading device descriptor: %d (%s)\\n", usbret, libusb_error_name(usbret));
            libusb_free_device_list(devices, 1);
            return NULL;
        }
        if (desc.idVendor == vid && desc.idProduct == pid) {
            printf("Found device\\n");
            printf("Bus %03i Device %03i: ID %04x:%04x\\n",
                libusb_get_bus_number(dev), libusb_get_device_address(dev),
                desc.idVendor, desc.idProduct);
            usbret = libusb_open(dev, &devh);
            if (usbret != 0) {
                printf("Error opening device: %d (%s)\\n", usbret, libusb_error_name(usbret));
                libusb_free_device_list(devices, 1);
                return NULL;
            }
            libusb_free_device_list(devices, 1);
            return devh;
        }
    }
    printf("Failed to find USB device\\n");
    libusb_free_device_list(devices, 1);
    return NULL;
}

int main(int argc, char **argv) {
    uint16_t vid = ''' + "0x%04X" % self.vid + ''';
    uint16_t pid = ''' + "0x%04X" % self.pid + ''';
    struct libusb_context *usb_ctx = NULL;
    libusb_device_handle *devh= NULL;
    int err;
    int bytes_transferred;
    (void)bytes_transferred;

    int ret = libusb_init(&usb_ctx);
    if (ret < 0 || usb_ctx == NULL) {
        printf("Error initializing libusb: %s\\n", libusb_error_name(ret));
        return 1;
    }
    devh = get_device(usb_ctx, vid, pid);

    /*
    err = libusb_set_configuration(devh, 1);
    if (err != 0) {
        printf("Error setting configuration: %d (%s)\\n", err, libusb_error_name(err));
        libusb_close(devh);
        libusb_exit(usb_ctx);
        return 1;
    }
    */
    err = libusb_claim_interface(devh, 0);
    if (err < 0) {
        printf("Error claiming interface: %d (%s)\\n", err, libusb_error_name(err));
        libusb_close(devh);
        libusb_exit(usb_ctx);
        return 1;
    }
    //dev.resetDevice()
    replay(devh);
}
''',
              file=printer.print_file)

    def packet_number_str(self, d):
        if self.packet_numbers:
            return "packet %s/%s" % (d["submit"]["packn"],
                                     d["complete"]["packn"])
        else:
            # TODO: consider counting instead of by captured index
            return "packet"

    def parse_data(self, d):
        if self.sleep and self.prevd and d["type"] != "comment":
            try:
                dt = gett(d) - gett(self.prevd)
            except KeyError:
                raise ValueError("Input JSON does not support timestamps")
            if dt >= 0.001:
                indented('time.sleep(%.3f)' % (dt, ))

        if d["type"] == "comment":
            comment(d["v"])
            return

        packet_numbering = self.packet_number_str(d)

        if "comments" in d:
            for c in d["comments"]:
                comment(c)

        if d["type"] == "controlRead":
            """
            int LIBUSB_CALL libusb_control_transfer(libusb_device_handle *dev_handle,
                uint8_t request_type, uint8_t bRequest, uint16_t wValue, uint16_t wIndex,
                unsigned char *data, uint16_t wLength, unsigned int timeout);
            """

            if d["wLength"]:
                data = "buff"
            else:
                data = "NULL"

            indented(
                "RET_ON_ERR(libusb_control_transfer(devh, 0x%02X, 0x%02X, 0x%04X, 0x%04X, %s, 0x%04X, timeout));"
                % (d["bRequestType"], d["bRequest"], d["wValue"], d["wIndex"],
                   data, d["wLength"]))
            indented(
                "RET_ON_ERR(validate_read(%s, %u, buff, usbret, \"%s\"));" % (
                    bytes2AnonArray(binascii.unhexlify(d["data"])),
                    len(d["data"]),
                    packet_numbering,
                ))
        elif d["type"] == "controlWrite":
            data_str = bytes2AnonArray(binascii.unhexlify(
                d["data"])) if d["data"] else "NULL"
            indented(
                "RET_ON_ERR(libusb_control_transfer(devh, 0x%02X, 0x%02X, 0x%04X, 0x%04X, %s, 0x%04X, timeout));"
                % (d["bRequestType"], d["bRequest"], d["wValue"], d["wIndex"],
                   data_str, len(d["data"])))

        elif d["type"] == "bulkRead":
            indented(
                "RET_ON_ERR(libusb_bulk_transfer(devh, 0x%02X, buff, 0x%04X, &bytes_transferred, timeout));"
                % (d["endp"], len(d["data"])))
            if len(d["data"]):
                indented(
                    "RET_ON_ERR(validate_read(%s, %u, buff, bytes_transferred, \"%s\"));"
                    % (
                        bytes2AnonArray(binascii.unhexlify(d["data"])),
                        len(d["data"]),
                        packet_numbering,
                    ))
        elif d["type"] == "bulkWrite":
            data_str = bytes2AnonArray(binascii.unhexlify(
                d["data"])) if d["data"] else "NULL"
            indented(
                "RET_ON_XFER_ERR(libusb_bulk_transfer(devh, 0x%02X, %s, 0x%04X, &bytes_transferred, timeout), 0x%04X);"
                % (d["endp"], data_str, len(d["data"]), len(d["data"])))
        elif d["type"] == "interruptIn":
            indented(
                "RET_ON_ERR(libusb_interrupt_transfer(devh, 0x%02X, buff, 0x%04X, &bytes_transferred, timeout));"
                % (d["endp"], len(d["data"])))
            if len(d["data"]):
                indented(
                    "RET_ON_ERR(validate_read(%s, %u, buff, bytes_transferred, \"%s\"));"
                    % (
                        bytes2AnonArray(binascii.unhexlify(d["data"])),
                        len(d["data"]),
                        packet_numbering,
                    ))
        elif d["type"] == "interruptOut":
            data_str = bytes2AnonArray(binascii.unhexlify(
                d["data"])) if d["data"] else "NULL"
            indented(
                "RET_ON_XFER_ERR(libusb_interrupt_transfer(devh, 0x%02X, %s, 0x%04X, &bytes_transferred, timeout), 0x%04X);"
                % (d["endp"], data_str, len(d["data"]), len(d["data"])))
        elif d["type"] == "irpInfo":
            comment("IRP_INFO(): func %s" %
                    (d["submit"]["urb"]["usb_func_str"], ))
        elif d["type"] == "abortPipe":
            comment("ABORT_PIPE()")
        else:
            if self.verbose:
                print("LibusbPyPrinter WARNING: dropping %s" % (d["type"], ))

        # these aren't event added to JSON right now
        # print('%s# WARNING: omitting interrupt' % (indent,))

        if d["type"] != "comment":
            self.prevd = d

    def run(self, jgen):
        indent_reset()
        self.header()

        # Last wire command (ie non-comment)
        # Used to optionally generate timing
        self.prevd = None

        # Convert generator into static JSON
        # caches vid/pid among other things
        j = parsers.jgen2j(jgen)

        for d in j["data"]:
            self.parse_data(d)

        if self.wrapper and (self.vid is None or self.pid is None):
            if len(j["device2vidpid"]) != 1:
                raise Exception(
                    "Failed to guess vid/pid: found %u device entries" %
                    len(j["device2vidpid"]))
            for (vid, pid) in j["device2vidpid"].values():
                self.vid = vid
                self.pid = pid
        if self.wrapper:
            self.footer()
